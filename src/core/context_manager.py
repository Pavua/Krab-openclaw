# -*- coding: utf-8 -*-
"""Source Code - Context Awareness

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cb86lGoWegkCD8FTVS--nMQtHeEZf18c
"""

# -*- coding: utf-8 -*-
"""
Context Manager.
Обеспечивает изоляцию памяти между чатами.
"""
import os
import json
from pathlib import Path

class ContextKeeper:
    def __init__(self, base_path="artifacts/memory"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)

    def get_chat_storage_path(self, chat_id: int) -> Path:
        """Возвращает путь к папке конкретного чата."""
        # Используем str(abs(chat_id)) чтобы убрать минус у ID групп
        chat_dir = self.base_path / str(abs(chat_id))
        chat_dir.mkdir(exist_ok=True)
        return chat_dir

    def save_message(self, chat_id: int, message_data: dict):
        """Сохраняет сообщение в историю чата (Append-only log для скорости)."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"

        with open(history_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(message_data, ensure_ascii=False) + "\n")

    def get_recent_context(self, chat_id: int, limit: int = 50):
        """Получает последние N сообщений для контекста."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"

        if not history_file.exists():
            return []

        try:
            with open(history_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
                # If limit is 0 or None, return ALL lines (careful with memory)
                if not limit:
                    return [json.loads(line) for line in lines]
                return [json.loads(line) for line in lines[-limit:]]
        except Exception as e:
            # logger.error(f"Error reading context: {e}")
            return []

    def save_summary(self, chat_id: int, summary: str):
        """Сохраняет саммари чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        summary_file = chat_dir / "summary.txt"
        with open(summary_file, "w", encoding="utf-8") as f:
            f.write(summary)

    def get_summary(self, chat_id: int) -> str:
        """Получает текущее саммари чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        summary_file = chat_dir / "summary.txt"
        if summary_file.exists():
            return summary_file.read_text(encoding="utf-8")
        return ""

# Пример использования в Pyrogram handler:
# keeper = ContextKeeper()
# @app.on_message()
# async def log_msg(client, message):
#     keeper.save_message(message.chat.id, {"user": message.from_user.id, "text": message.text})