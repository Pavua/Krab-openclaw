# -*- coding: utf-8 -*-
"""Source Code - Context Awareness

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cb86lGoWegkCD8FTVS--nMQtHeEZf18c
"""

# -*- coding: utf-8 -*-
"""
Context Manager.
Обеспечивает изоляцию памяти между чатами.
"""
import os
import json
from pathlib import Path

class ContextKeeper:
    def __init__(self, base_path="artifacts/memory"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)

    def get_chat_storage_path(self, chat_id: int) -> Path:
        """Возвращает путь к папке конкретного чата."""
        # Используем str(abs(chat_id)) чтобы убрать минус у ID групп
        chat_dir = self.base_path / str(abs(chat_id))
        chat_dir.mkdir(exist_ok=True)
        return chat_dir

    @staticmethod
    def _normalize_role(role: str | None) -> str:
        """Приводит роль к совместимому набору user/assistant/system/tool."""
        normalized = str(role or "user").strip().lower()
        if normalized in {"user", "assistant", "system", "tool"}:
            return normalized
        if normalized in {"model", "bot", "ai", "vision_analysis"}:
            return "assistant"
        if normalized in {"memory", "analysis", "context", "note"}:
            return "system"
        return "user"

    @classmethod
    def _normalize_message_payload(cls, message_data: dict) -> dict:
        """Нормализует сообщение перед сохранением/выдачей контекста."""
        if not isinstance(message_data, dict):
            return {"role": "user", "text": str(message_data)}
        normalized = dict(message_data)
        normalized["role"] = cls._normalize_role(normalized.get("role"))
        # Выравниваем поле content/text для старых форматов.
        if not normalized.get("text") and normalized.get("content"):
            normalized["text"] = str(normalized.get("content"))
        return normalized

    @staticmethod
    def _is_service_artifact_text(text: str) -> bool:
        """
        Определяет служебные фразы, которые не должны попадать в AI-контекст.
        """
        payload = str(text or "").strip().lower()
        if not payload:
            return False
        patterns = (
            "обрабатываю предыдущий запрос",
            "отправь следующее сообщение через пару секунд",
            "добавил в очередь обработки",
            "подожди пару секунд и повтори",
            "очередь переполнена для этого чата",
        )
        return any(p in payload for p in patterns)

    def save_message(self, chat_id: int, message_data: dict):
        """Сохраняет сообщение в историю чата (Append-only log для скорости)."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"
        payload = self._normalize_message_payload(message_data)
        if self._is_service_artifact_text(payload.get("text", "")):
            return False

        with open(history_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(payload, ensure_ascii=False) + "\n")
        return True

    def get_recent_context(self, chat_id: int, limit: int = 50):
        """Получает последние N сообщений для контекста."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"

        if not history_file.exists():
            return []

        try:
            with open(history_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
                # If limit is 0 or None, return ALL lines (careful with memory)
                if not limit:
                    return [self._normalize_message_payload(json.loads(line)) for line in lines]
                return [self._normalize_message_payload(json.loads(line)) for line in lines[-limit:]]
        except Exception as e:
            # logger.error(f"Error reading context: {e}")
            return []

    async def sync_telegram_history(self, client, chat_id: int, limit: int = 50):
        """
        Синхронизирует историю сообщений с Telegram.
        Если локальная история пуста, загружает последние N сообщений.
        """
        history_file = self.get_chat_storage_path(chat_id) / "history.jsonl"
        
        # Если файл уже содержит сообщения, считаем что синхронизация не нужна 
        # (или можно добавить проверку по времени/количеству)
        if history_file.exists() and history_file.stat().st_size > 0:
            return False

        try:
            from pyrogram.enums import MessageServiceType
            
            messages = []
            async for message in client.get_chat_history(chat_id, limit=limit):
                if not message.text and not message.caption:
                    continue
                
                role = "assistant" if message.from_user and message.from_user.is_self else "user"
                sender = message.from_user.username if message.from_user else "Unknown"
                
                messages.append({
                    "role": role,
                    "user": sender,
                    "text": message.text or message.caption,
                    "timestamp": message.date.timestamp() if message.date else 0
                })
            
            # Сохраняем в обратном порядке (от старых к новым)
            for msg in reversed(messages):
                self.save_message(chat_id, msg)
            
            return True
        except Exception as e:
            # logger.error(f"Failed to sync history for {chat_id}: {e}")
            return False

    def save_summary(self, chat_id: int, summary: str):
        """Сохраняет саммари чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        summary_file = chat_dir / "summary.txt"
        with open(summary_file, "w", encoding="utf-8") as f:
            f.write(summary)

    def get_summary(self, chat_id: int) -> str:
        """Получает текущее саммари чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        summary_file = chat_dir / "summary.txt"
        if summary_file.exists():
            return summary_file.read_text(encoding="utf-8")
        return ""

    def _estimate_tokens(self, text: str) -> int:
        """
        Грубая оценка количества токенов.
        Для кириллицы и латиницы в среднем 1 токен ≈ 4 символа.
        """
        if not text:
            return 0
        return len(text) // 4 + 1

    def get_token_aware_context(self, chat_id: int, max_tokens: int = 4000) -> list:
        """
        Получает контекст, не превышающий лимит токенов.
        Идет по истории с конца, пока не наберет нужный объем.
        """
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"

        if not history_file.exists():
            return []

        try:
            with open(history_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
            
            context = []
            current_tokens = 0
            
            # Читаем с конца (свежие сообщения важнее)
            for line in reversed(lines):
                msg = self._normalize_message_payload(json.loads(line))
                msg_tokens = self._estimate_tokens(msg.get("text", ""))
                
                if current_tokens + msg_tokens > max_tokens:
                    break
                
                context.insert(0, msg)
                current_tokens += msg_tokens
                
            return context
        except Exception as e:
            return []

    def clear_history(self, chat_id: int):
        """Полная очистка истории конкретного чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"
        summary_file = chat_dir / "summary.txt"
        
        if history_file.exists():
            os.remove(history_file)
        if summary_file.exists():
            os.remove(summary_file)
        return True

# Пример использования в Pyrogram handler:
# keeper = ContextKeeper()
# @app.on_message()
# async def log_msg(client, message):
#     keeper.save_message(message.chat.id, {"user": message.from_user.id, "text": message.text})
