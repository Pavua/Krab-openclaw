# -*- coding: utf-8 -*-
"""Source Code - Context Awareness

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cb86lGoWegkCD8FTVS--nMQtHeEZf18c
"""

# -*- coding: utf-8 -*-
"""
Context Manager.
Обеспечивает изоляцию памяти между чатами.
"""
import os
import json
from pathlib import Path

class ContextKeeper:
    def __init__(self, base_path="artifacts/memory"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)

    def get_chat_storage_path(self, chat_id: int) -> Path:
        """Возвращает путь к папке конкретного чата."""
        # Используем str(abs(chat_id)) чтобы убрать минус у ID групп
        chat_dir = self.base_path / str(abs(chat_id))
        chat_dir.mkdir(exist_ok=True)
        return chat_dir

    def save_message(self, chat_id: int, message_data: dict):
        """Сохраняет сообщение в историю чата (Append-only log для скорости)."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"

        with open(history_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(message_data, ensure_ascii=False) + "\n")

    def get_recent_context(self, chat_id: int, limit: int = 50):
        """Получает последние N сообщений для контекста."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"

        if not history_file.exists():
            return []

        try:
            with open(history_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
                # If limit is 0 or None, return ALL lines (careful with memory)
                if not limit:
                    return [json.loads(line) for line in lines]
                return [json.loads(line) for line in lines[-limit:]]
        except Exception as e:
            # logger.error(f"Error reading context: {e}")
            return []

    async def sync_telegram_history(self, client, chat_id: int, limit: int = 50):
        """
        Синхронизирует историю сообщений с Telegram.
        Если локальная история пуста, загружает последние N сообщений.
        """
        history_file = self.get_chat_storage_path(chat_id) / "history.jsonl"
        
        # Если файл уже содержит сообщения, считаем что синхронизация не нужна 
        # (или можно добавить проверку по времени/количеству)
        if history_file.exists() and history_file.stat().st_size > 0:
            return False

        try:
            from pyrogram.enums import MessageServiceType
            
            messages = []
            async for message in client.get_chat_history(chat_id, limit=limit):
                if not message.text and not message.caption:
                    continue
                
                role = "assistant" if message.from_user and message.from_user.is_self else "user"
                sender = message.from_user.username if message.from_user else "Unknown"
                
                messages.append({
                    "role": role,
                    "user": sender,
                    "text": message.text or message.caption,
                    "timestamp": message.date.timestamp() if message.date else 0
                })
            
            # Сохраняем в обратном порядке (от старых к новым)
            for msg in reversed(messages):
                self.save_message(chat_id, msg)
            
            return True
        except Exception as e:
            # logger.error(f"Failed to sync history for {chat_id}: {e}")
            return False

    def save_summary(self, chat_id: int, summary: str):
        """Сохраняет саммари чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        summary_file = chat_dir / "summary.txt"
        with open(summary_file, "w", encoding="utf-8") as f:
            f.write(summary)

    def get_summary(self, chat_id: int) -> str:
        """Получает текущее саммари чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        summary_file = chat_dir / "summary.txt"
        if summary_file.exists():
            return summary_file.read_text(encoding="utf-8")
        return ""

    def clear_history(self, chat_id: int):
        """Полная очистка истории конкретного чата."""
        chat_dir = self.get_chat_storage_path(chat_id)
        history_file = chat_dir / "history.jsonl"
        summary_file = chat_dir / "summary.txt"
        
        if history_file.exists():
            os.remove(history_file)
        if summary_file.exists():
            os.remove(summary_file)
        return True

# Пример использования в Pyrogram handler:
# keeper = ContextKeeper()
# @app.on_message()
# async def log_msg(client, message):
#     keeper.save_message(message.chat.id, {"user": message.from_user.id, "text": message.text})