# -*- coding: utf-8 -*-
"""Main Entry Point

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZOGTxnMYg7Rz_IIxlgqOD3PmErK11vPS
"""

# -*- coding: utf-8 -*-
"""
Krab v2.0 - Core Entry Point (Orchestrator)
–≠—Ç–æ—Ç —Ñ–∞–π–ª —Å–≤—è–∑—ã–≤–∞–µ—Ç Pyrogram, Model Router –∏ Context Manager.
"""

import os
import asyncio
import logging
from dotenv import load_dotenv
from pyrogram import Client, filters, idle, enums
from pyrogram.types import Message

# –ò–º–ø–æ—Ä—Ç –Ω–∞—à–∏—Ö –Ω–æ–≤—ã—Ö —è–¥–µ—Ä–Ω—ã—Ö –º–æ–¥—É–ª–µ–π
from src.core.model_manager import ModelRouter
from src.core.context_manager import ContextKeeper
from src.modules.perceptor import Perceptor

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("logs/krab.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("KrabMain")

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
load_dotenv()

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
API_ID = os.getenv("TELEGRAM_API_ID")
API_HASH = os.getenv("TELEGRAM_API_HASH")
SESSION_NAME = os.getenv("TELEGRAM_SESSION_NAME", "krab_v2_session")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
# Config for Perceptor (loaded from env or defaults)
perceptor_config = {
    "WHISPER_MODEL": "mlx-community/whisper-large-v3-turbo"
}

router = ModelRouter(config=os.environ)
memory = ContextKeeper()
perceptor = Perceptor(config=perceptor_config) # –ú–æ–¥—É–ª—å "–ì–ª–∞–∑–∞ –∏ –£—à–∏"

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ (Userbot)
app = Client(SESSION_NAME, api_id=API_ID, api_hash=API_HASH)

# --- GLOBAL DEBUG LOGGER ---
@app.on_message(group=-1)
async def debug_logger(client, message: Message):
    sender = message.from_user.username if message.from_user else "Unknown"
    msg_type = message.media.value if message.media else "Text"
    logger.info(f"üîç DEBUG: New Message from @{sender} ({message.chat.id}). Type: {msg_type}. Text: {message.text or message.caption or 'None'}")

# --- EVENT HANDLERS ---

@app.on_message(filters.command("status", prefixes="!"))
async def status_check(client, message):
    """–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º (Router + Local Server)."""
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ (–∫–∞–∫ –≤ auto_reply)
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner: allowed_users.append(owner)
    
    sender = message.from_user.username if message.from_user else "Unknown"
    sender_id = str(message.from_user.id) if message.from_user else "0"
    
    if sender not in allowed_users and sender_id not in allowed_users:
        return

    msg_method = message.edit_text if message.from_user.is_self else message.reply_text
    status_msg = await msg_method("ü¶Ä Checking systems...")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ AI
    await router.check_local_health()
    local_status = "üü¢ Online" if router.is_local_available else "üî¥ Offline"
    model_name = router.active_local_model or "None"

    text = (
        f"**Krab v2.0 Systems:**\n"
        f"üß† **AI Core:** Hybrid (Cloud + Local)\n"
        f"üè† **Local LLM:** {local_status} ({model_name})\n"
        f"üëÇ **Ears:** Active (Whisper)\n"
        f"üëÅÔ∏è **Eyes:** Active (Vision)"
    )
    
    if message.from_user.is_self:
        await status_msg.edit_text(text)
    else:
        await status_msg.edit_text(text) # reply_text returns a message which we can edit

@app.on_message(filters.command("summary", prefixes="!"))
async def summarize_chat(client, message):
    """–°–∞–º–º–∞—Ä–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–ø–∏—Å–∫–∏ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 50-100 —Å–æ–æ–±—â–µ–Ω–∏–π)."""
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤
    sender = message.from_user.username if message.from_user else "Unknown"
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner: allowed_users.append(owner)

    if sender not in allowed_users and not message.from_user.is_self:
        return

    notification = await message.reply_text("üßê –ß–∏—Ç–∞—é –∏—Å—Ç–æ—Ä–∏—é...")
    
    # 1. –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å–æ–æ–±—â–µ–Ω–∏–π)
    # limit=0 gets all, but lets keep it 100 for safety
    history = memory.get_recent_context(message.chat.id, limit=100)
    
    if not history:
        await notification.edit_text("‚ùå –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.")
        return

    # 2. –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç
    messages_text = ""
    for msg in history:
        role = msg.get('user', msg.get('role', 'unknown'))
        content = msg.get('text', msg.get('content', '[media]'))
        messages_text += f"{role}: {content}\n"

    prompt = (
        "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç—É –ø–µ—Ä–µ–ø–∏—Å–∫—É –∏ —Å–æ—Å—Ç–∞–≤—å –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ (Summary).\n"
        "–í—ã–¥–µ–ª–∏ –≥–ª–∞–≤–Ω—ã–µ —Ç–µ–º—ã, –¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –∏ –≤–∞–∂–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã.\n"
        "–°—Ç–∏–ª—å: –ö—Ä–∞—Ç–∫–∏–π, –¥–µ–ª–æ–≤–æ–π, —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±—É–ª–ª–ª–∏—Ç–∞–º–∏.\n\n"
        f"–ü–µ—Ä–µ–ø–∏—Å–∫–∞:\n{messages_text}"
    )

    # 3. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ AI
    summary = await router.route_query(prompt, task_type='chat')
    
    await notification.edit_text(f"üìù **Summary:**\n\n{summary}")

@app.on_message(filters.command("say", prefixes="!"))
async def say_text(client, message):
    """Text-to-Speech: !say <text> or reply to text."""
    # Check permissions (reuse logic or improve)
    sender = message.from_user.username if message.from_user else "Unknown"
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner: allowed_users.append(owner)

    if sender not in allowed_users and not message.from_user.is_self:
        return

    # Determine text
    text_to_speak = ""
    if len(message.command) > 1:
        text_to_speak = message.text.split(" ", 1)[1]
    elif message.reply_to_message:
        text_to_speak = message.reply_to_message.text or message.reply_to_message.caption
    
    if not text_to_speak:
         await message.reply_text("üó£Ô∏è –£–∫–∞–∂–∏ —Ç–µ–∫—Å—Ç: `!say –ü—Ä–∏–≤–µ—Ç` –∏–ª–∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
         return

    notification = await message.reply_text("üó£Ô∏è –ì–µ–Ω–µ—Ä–∏—Ä—É—é –≥–æ–ª–æ—Å...")
    
    # Call Perceptor TTS
    # Default voice is Milena (Russian). 
    voice_path = await perceptor.speak(text_to_speak, voice="Milena")
    
    if voice_path and os.path.exists(voice_path):
        await message.reply_voice(voice_path, caption=f"üó£Ô∏è **Said:** {text_to_speak[:20]}...")
        await notification.delete()
        os.remove(voice_path)
    else:
        await notification.edit_text("‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥–æ–ª–æ—Å–∞.")

@app.on_message(filters.command("translate", prefixes="!"))
async def translate_text(client, message):
    """–ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞: !translate <text> –∏–ª–∏ —Ä–µ–ø–ª–∞–µ–º –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ.
    –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–µ–≤–æ–¥–∏—Ç: RU -> EN, EN -> RU (–∞–≤—Ç–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ).
    –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —è–∑—ã–∫: !translate en –ü—Ä–∏–≤–µ—Ç –º–∏—Ä
    """
    sender = message.from_user.username if message.from_user else "Unknown"
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner: allowed_users.append(owner)
    if sender not in allowed_users and not message.from_user.is_self:
        return

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
    text_to_translate = ""
    target_lang = None  # –ê–≤—Ç–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ

    if len(message.command) > 1:
        args = message.text.split(" ", 1)[1]
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —É–∫–∞–∑–∞–Ω –ª–∏ —è–∑—ã–∫ –ø–µ—Ä–≤—ã–º —Å–ª–æ–≤–æ–º
        first_word = args.split(" ", 1)[0].lower()
        if first_word in ["en", "ru", "es", "fr", "de", "zh", "ja", "ko", "ar", "pt", "it"]:
            target_lang = first_word
            text_to_translate = args.split(" ", 1)[1] if len(args.split(" ", 1)) > 1 else ""
        else:
            text_to_translate = args
    elif message.reply_to_message:
        text_to_translate = message.reply_to_message.text or message.reply_to_message.caption

    if not text_to_translate:
        await message.reply_text("üåê –£–∫–∞–∂–∏ —Ç–µ–∫—Å—Ç: `!translate –ü—Ä–∏–≤–µ—Ç` –∏–ª–∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n"
                                 "–ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —è–∑—ã–∫: `!translate en –ü—Ä–∏–≤–µ—Ç –º–∏—Ä`")
        return

    notification = await message.reply_text("üåê –ü–µ—Ä–µ–≤–æ–∂—É...")

    # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞
    if target_lang:
        lang_map = {"en": "English", "ru": "Russian", "es": "Spanish", "fr": "French",
                    "de": "German", "zh": "Chinese", "ja": "Japanese", "ko": "Korean",
                    "ar": "Arabic", "pt": "Portuguese", "it": "Italian"}
        lang_name = lang_map.get(target_lang, target_lang)
        prompt = f"–ü–µ—Ä–µ–≤–µ–¥–∏ —ç—Ç–æ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ {lang_name}. –í—ã–≤–µ–¥–∏ –¢–û–õ–¨–ö–û –ø–µ—Ä–µ–≤–æ–¥, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π.\n\n{text_to_translate}"
    else:
        prompt = ("–û–ø—Ä–µ–¥–µ–ª–∏ —è–∑—ã–∫ —ç—Ç–æ–≥–æ —Ç–µ–∫—Å—Ç–∞. –ï—Å–ª–∏ —ç—Ç–æ —Ä—É—Å—Å–∫–∏–π ‚Äî –ø–µ—Ä–µ–≤–µ–¥–∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π. "
                  "–ï—Å–ª–∏ —ç—Ç–æ –ª—é–±–æ–π –¥—Ä—É–≥–æ–π —è–∑—ã–∫ ‚Äî –ø–µ—Ä–µ–≤–µ–¥–∏ –Ω–∞ —Ä—É—Å—Å–∫–∏–π. "
                  "–í—ã–≤–µ–¥–∏ –¢–û–õ–¨–ö–û –ø–µ—Ä–µ–≤–æ–¥, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π.\n\n"
                  f"{text_to_translate}")

    translation = await router.route_query(prompt, task_type='chat')
    await notification.edit_text(f"üåê **Translation:**\n\n{translation}")

@app.on_message(filters.command("diagnose", prefixes="!"))
async def diagnose_system(client, message):
    """–ü–æ–ª–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –≤—Å–µ—Ö –ø–æ–¥—Å–∏—Å—Ç–µ–º –ö—Ä–∞–±–∞."""
    sender = message.from_user.username if message.from_user else "Unknown"
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner: allowed_users.append(owner)
    if sender not in allowed_users and not message.from_user.is_self:
        return

    notification = await message.reply_text("üîç –ó–∞–ø—É—Å–∫–∞—é –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É...")

    import psutil
    import platform
    
    # 1. –°–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
    cpu = psutil.cpu_percent(interval=0.5)
    ram = psutil.virtual_memory()
    disk = psutil.disk_usage('/')
    
    # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ Local AI
    await router.check_local_health()
    local_status = "üü¢ Online" if router.is_local_available else "üî¥ Offline"
    local_model = router.active_local_model or "N/A"
    
    # 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ Gemini
    gemini_status = "üü¢ Key Present" if router.gemini_key else "üî¥ No Key"
    
    # 4. –î–∏—Å–∫–µ—Ü–∏—è –ø–∞–º—è—Ç–∏ –±–æ—Ç–∞
    history_count = len(memory.get_recent_context(message.chat.id, limit=0))
    
    # 5. Python / Platform info
    py_ver = platform.python_version()
    mac_ver = platform.mac_ver()[0]
    chip = platform.processor() or "Apple Silicon"
    
    text = (
        f"**ü¶Ä Krab v2.0 ‚Äî –ü–æ–ª–Ω–∞—è –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞**\n\n"
        f"**–°–∏—Å—Ç–µ–º–∞:**\n"
        f"‚îú macOS {mac_ver} ({chip})\n"
        f"‚îú Python {py_ver}\n"
        f"‚îú CPU: {cpu}%\n"
        f"‚îú RAM: {ram.percent}% ({ram.used // (1024**3)}/{ram.total // (1024**3)} GB)\n"
        f"‚îî Disk: {disk.percent}% ({disk.used // (1024**3)}/{disk.total // (1024**3)} GB)\n\n"
        f"**AI Core:**\n"
        f"‚îú Local LLM: {local_status} ({local_model})\n"
        f"‚îú Gemini API: {gemini_status}\n"
        f"‚îî Whisper: üü¢ Active ({perceptor.whisper_model})\n\n"
        f"**Modules:**\n"
        f"‚îú üëÇ Ears (STT): Active\n"
        f"‚îú üó£Ô∏è Voice (TTS): Active (Milena)\n"
        f"‚îú üëÅÔ∏è Eyes (Vision): Active\n"
        f"‚îú üìù Summary: Active\n"
        f"‚îú üåê Translate: Active\n"
        f"‚îî üíæ Memory: {history_count} msgs (this chat)\n\n"
        f"**Uptime:** Running as @{(await client.get_me()).username}"
    )
    
    await notification.edit_text(text)

@app.on_message(filters.command("code", prefixes="!"))
async def generate_code(client, message):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞: !code <–∑–∞–¥–∞—á–∞>. –ò—Å–ø–æ–ª—å–∑—É—è AI –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞."""
    sender = message.from_user.username if message.from_user else "Unknown"
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner: allowed_users.append(owner)
    if sender not in allowed_users and not message.from_user.is_self:
        return

    task = ""
    if len(message.command) > 1:
        task = message.text.split(" ", 1)[1]
    elif message.reply_to_message:
        task = message.reply_to_message.text or message.reply_to_message.caption

    if not task:
        await message.reply_text("üíª –û–ø–∏—à–∏ –∑–∞–¥–∞—á—É: `!code –ù–∞–ø–∏—à–∏ –ø–∞—Ä—Å–µ—Ä JSON`")
        return

    notification = await message.reply_text("üíª –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∫–æ–¥...")

    prompt = (
        "–¢—ã ‚Äî –æ–ø—ã—Ç–Ω—ã–π Python-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫. "
        "–ù–∞–ø–∏—à–∏ —á–∏—Å—Ç—ã–π, —Ä–∞–±–æ—á–∏–π –∫–æ–¥ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏. "
        "–í–µ—Ä–Ω–∏ –¢–û–õ–¨–ö–û –∫–æ–¥ –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ ```python ... ```. "
        "–î–æ–±–∞–≤—å –∫—Ä–∞—Ç–∫–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º.\n\n"
        f"–ó–∞–¥–∞—á–∞: {task}"
    )

    code = await router.route_query(prompt, task_type='coding')
    await notification.edit_text(f"üíª **Code:**\n\n{code}")

@app.on_message(filters.command("exec", prefixes="!"))
async def exec_python(client, message):
    """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ Python-–∫–æ–¥–∞ (–¢–û–õ–¨–ö–û –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞).
    !exec print('hello') –∏–ª–∏ —Ä–µ–ø–ª–∞–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–æ–¥–æ–º.
    ‚ö†Ô∏è –û–ø–∞—Å–Ω–æ! –¢–æ–ª—å–∫–æ –¥–ª—è OWNER.
    """
    # –°–¢–†–û–ì–û —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    sender = message.from_user.username if message.from_user else "Unknown"
    
    if sender != owner and not message.from_user.is_self:
        await message.reply_text("üîí –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª—å—Ü—É.")
        return

    code = ""
    if len(message.command) > 1:
        code = message.text.split(" ", 1)[1]
    elif message.reply_to_message:
        code = message.reply_to_message.text or message.reply_to_message.caption

    if not code:
        await message.reply_text("‚öôÔ∏è –£–∫–∞–∂–∏ –∫–æ–¥: `!exec print('hello')`")
        return

    # –£–±–∏—Ä–∞–µ–º markdown-–æ–±—ë—Ä—Ç–∫—É –µ—Å–ª–∏ –µ—Å—Ç—å
    if code.startswith("```") and code.endswith("```"):
        code = code.strip("```")
        if code.startswith("python\n"):
            code = code[7:]

    notification = await message.reply_text("‚öôÔ∏è –í—ã–ø–æ–ª–Ω—è—é...")

    import io
    import sys
    import traceback

    # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å –ø–µ—Ä–µ—Ö–≤–∞—Ç–æ–º stdout/stderr
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    sys.stdout = captured_out = io.StringIO()
    sys.stderr = captured_err = io.StringIO()

    try:
        # –¢–∞–π–º–∞—É—Ç 10 —Å–µ–∫—É–Ω–¥ (–∑–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤)
        exec(code, {"__builtins__": __builtins__})
        output = captured_out.getvalue()
        error = captured_err.getvalue()
        
        result = ""
        if output:
            result += f"üì§ **Output:**\n```\n{output[:3000]}\n```\n"
        if error:
            result += f"‚ö†Ô∏è **Stderr:**\n```\n{error[:1000]}\n```\n"
        if not output and not error:
            result = "‚úÖ –ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω –±–µ–∑ –≤—ã–≤–æ–¥–∞."
        
        await notification.edit_text(result)
    except Exception as e:
        tb = traceback.format_exc()
        await notification.edit_text(f"‚ùå **Error:**\n```\n{tb[-2000:]}\n```")
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr

@app.on_message(filters.command("help", prefixes="!"))
async def show_help(client, message):
    """–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –±–æ—Ç–∞."""
    text = (
        "**ü¶Ä Krab v2.0 ‚Äî –ö–æ–º–∞–Ω–¥—ã:**\n\n"
        "**–û—Å–Ω–æ–≤–Ω—ã–µ:**\n"
        "`!status` ‚Äî –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è AI —Å–∏—Å—Ç–µ–º\n"
        "`!diagnose` ‚Äî –ü–æ–ª–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ (CPU, RAM, –º–æ–¥—É–ª–∏)\n"
        "`!help` ‚Äî –≠—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n"
        "**AI:**\n"
        "`!summary` ‚Äî –°–∞–º–º–∞—Ä–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 100 —Å–æ–æ–±—â–µ–Ω–∏–π\n"
        "`!translate [lang] <text>` ‚Äî –ü–µ—Ä–µ–≤–æ–¥ (–∞–≤—Ç–æ RU‚ÜîEN)\n"
        "`!say <text>` ‚Äî –û–∑–≤—É—á–∏—Ç—å (–≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ)\n"
        "`!code <–∑–∞–¥–∞—á–∞>` ‚Äî –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Python-–∫–æ–¥–∞\n\n"
        "**Dev (Owner only):**\n"
        "`!exec <code>` ‚Äî –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ Python –∫–æ–¥–∞\n\n"
        "**–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ:**\n"
        "üé§ –ì–æ–ª–æ—Å–æ–≤—ã–µ ‚Üí –ê–≤—Ç–æ-—Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è + –æ—Ç–≤–µ—Ç\n"
        "üì∏ –§–æ—Ç–æ ‚Üí –ê–≤—Ç–æ-–∞–Ω–∞–ª–∏–∑ + –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π\n"
        "üí¨ –¢–µ–∫—Å—Ç ‚Üí –ê–≤—Ç–æ-–æ—Ç–≤–µ—Ç (–¥–ª—è –±–µ–ª–æ–≥–æ —Å–ø–∏—Å–∫–∞)\n\n"
        "**–ü–æ–¥—Å–∫–∞–∑–∫–∏:**\n"
        "‚Ä¢ –†–µ–ø–ª–∞–π —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è: `!translate`, `!say`, `!code`, `!exec`\n"
        "‚Ä¢ `!translate en –¢–µ–∫—Å—Ç` ‚Äî –ø–µ—Ä–µ–≤–æ–¥ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —è–∑—ã–∫"
    )
    await message.reply_text(text)

@app.on_message(filters.voice | filters.audio | filters.document)
async def handle_audio(client, message: Message):
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö (—á–µ—Ä–µ–∑ Perceptor)."""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞—É–¥–∏–æ –ª–∏ —ç—Ç–æ, —Ç.–∫. —Ñ–∏–ª—å—Ç—Ä document –ª–æ–≤–∏—Ç –≤—Å–µ
    is_audio = message.voice or message.audio or (message.document and "audio" in message.document.mime_type)
    
    if not is_audio:
        return # Skip non-audio documents

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—ä–µ–∫—Ç –º–µ–¥–∏–∞
    media = message.voice or message.audio or message.document
    if not media:
        return

    # –õ–æ–≥–∏–∫–∞: –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –õ–° –º–Ω–µ –∏–ª–∏ —è —É–ø–æ–º—è–Ω—É—Ç - —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä–æ–≤–∞—Ç—å
    is_private = message.chat.type == enums.ChatType.PRIVATE
    if is_private or (message.caption and "!txt" in message.caption):
        logger.info(f"Processing audio from {message.chat.id}")

        # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–∞–π–ª
        file_path = await message.download(file_name=f"artifacts/downloads/{media.file_unique_id}.ogg")
        
        # –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É–µ–º (–õ–æ–∫–∞–ª—å–Ω–æ –∏–ª–∏ —á–µ—Ä–µ–∑ API)
        notification = await message.reply_text("üëÇ –°–ª—É—à–∞—é...")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª (–∏–Ω–æ–≥–¥–∞ download –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None –ø—Ä–∏ –æ—à–∏–±–∫–µ)
        if not file_path or not os.path.exists(file_path):
             await notification.edit_text("‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞.")
             return

        text = await perceptor.transcribe(file_path, router)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        memory.save_message(message.chat.id, {"role": "audio_transcript", "content": text})

        await notification.edit_text(f"**Transcript:** `{text}`\n\nü§î –î—É–º–∞—é...")
        
        # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç —É AI
        context = memory.get_recent_context(message.chat.id, limit=5)
        voice_prompt = f"[–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]: {text}"
        
        response_text = await router.route_query(
            prompt=voice_prompt,
            task_type='chat',
            context=context
        )
        
        await message.reply_text(response_text)
        memory.save_message(message.chat.id, {"role": "assistant", "text": response_text})
        
        # –§–∏–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        await notification.edit_text(f"**Transcript:**\n\n{text}")

        # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
        os.remove(file_path)

@app.on_message(filters.photo)
async def handle_vision(client, message: Message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–≤–∫–ª—é—á–∞—è HEIC)."""
    # –†–µ–∞–≥–∏—Ä—É–µ–º –µ—Å–ª–∏ –µ—Å—Ç—å caption !scan –∏–ª–∏ !vision, –ò–õ–ò –µ—Å–ª–∏ —ç—Ç–æ –õ–° —Å –±–æ—Ç–æ–º (–∞–≤—Ç–æ-—Å–∫–∞–Ω)
    is_private = message.chat.type == enums.ChatType.PRIVATE
    should_scan = (message.caption and ("!scan" in message.caption or "!vision" in message.caption)) or is_private
    
    if should_scan:
        notification = await message.reply_text("üëÅÔ∏è –°–º–æ—Ç—Ä—é...")
        file_path = await message.download(file_name=f"artifacts/downloads/{message.file.unique_id}")
        
        # –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        description = await perceptor.analyze_image(file_path, router, prompt="–ß—Ç–æ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏? –û–ø–∏—à–∏ –ø–æ–¥—Ä–æ–±–Ω–æ.")
        memory.save_message(message.chat.id, {"role": "vision_analysis", "content": description})
        
        await notification.edit_text(f"üëÅÔ∏è **Vision:** `{description}`\n\nü§î –î—É–º–∞—é...")
        
        # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ä–µ–∞–∫—Ü–∏—é AI
        context = memory.get_recent_context(message.chat.id, limit=5)
        vision_prompt = f"[–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–∏—Å–ª–∞–ª —Ñ–æ—Ç–æ]: {description}. –ü—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π –∏–ª–∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å."
        if message.caption:
            vision_prompt += f"\n–ü–æ–¥–ø–∏—Å—å: {message.caption}"

        response_text = await router.route_query(
            prompt=vision_prompt,
            task_type='chat',
            context=context
        )
        
        await message.reply_text(response_text)
        memory.save_message(message.chat.id, {"role": "assistant", "text": response_text})
        
        await notification.edit_text(f"**Vision Analysis:**\n\n{description}")
        os.remove(file_path)

@app.on_message(filters.text & ~filters.me & ~filters.bot)
async def auto_reply_logic(client, message: Message):
    """
    –£–º–Ω—ã–π –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫.
    –°—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç, –µ—Å–ª–∏:
    1. –≠—Ç–æ –õ–° –∏–ª–∏ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ.
    2. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ.
    """
    if message.text is None: return # –ó–∞—â–∏—Ç–∞ –æ—Ç —Å—Ç—Ä–∞–Ω–Ω—ã—Ö –∞–ø–¥–µ–π—Ç–æ–≤

    # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞
    allowed_users = os.getenv("ALLOWED_USERS", "").split(",")
    # –û—á–∏—Å—Ç–∫–∞ —Å–ø–∏—Å–∫–∞ –æ—Ç –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫
    allowed_users = [u.strip() for u in allowed_users if u.strip()]
    
    # –î–æ–±–∞–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞
    owner = os.getenv("OWNER_USERNAME", "").replace("@", "").strip()
    if owner:
        allowed_users.append(owner)

    sender = message.from_user.username if message.from_user else "Unknown"
    sender_id = str(message.from_user.id) if message.from_user else "0"
    
    logger.info(f"üì© Msg from @{sender}. Allowed: {allowed_users}")

    # –ï—Å–ª–∏ –≤ —Å–ø–∏—Å–∫–µ –µ—Å—Ç—å –∞–¥–º–∏–Ω—ã –ø–æ ID - –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É ID
    # –ü–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ username (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
    if sender not in allowed_users and sender_id not in allowed_users:
        logger.info(f"‚õî Ignored unauthorized message from @{sender}")
        return

    # 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç (User Msg)
    memory.save_message(message.chat.id, {
        "user": sender,
        "text": message.text
    })

    # 3. –ú–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
    # –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    context = memory.get_recent_context(message.chat.id, limit=10)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º "–ø–µ—á–∞—Ç–∞–µ—Ç..."
    await client.send_chat_action(message.chat.id, action=enums.ChatAction.TYPING)

    # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –æ—Ç–≤–µ—Ç —É AI
    response_text = await router.route_query(
        prompt=message.text,
        task_type='chat',
        context=context
    )

    # 4. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
    await message.reply_text(response_text)

    # 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç (Bot Msg)
    memory.save_message(message.chat.id, {
        "role": "assistant",
        "text": response_text
    })

# --- MAIN LOOP ---

async def main():
    logger.info("Starting Krab v2.0...")
    await app.start()

    # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–æ—É—Ç–µ—Ä–∞
    await router.check_local_health()
    me = await app.get_me()
    logger.info(f"Logged in as {me.first_name} (@{me.username})")
    
    # Notify Owner (@p0lrd)
    try:
        await app.send_message("p0lrd", "ü¶Ä Krab v2.0 Online.\n‚úÖ System Prompt: Loaded (v2).\n‚úÖ Tests: 6/6 Passed (Context, Perceptor).\n‚úÖ Audio/Vision: Active.")
    except Exception as e:
        logger.warning(f"Could not key message to @p0lrd: {e}")

    await idle()
    await app.stop()

if __name__ == "__main__":
    app.run(main())