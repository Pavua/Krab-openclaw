<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Krab Web Panel V2</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="nano_theme.css">
    <style>
        /* ----- GRID SYSTEM (Page Specific) ----- */
        .grid-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .grid-middle {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 24px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        /* ----- SPECIFIC COMPONENTS ----- */
        /* Assistant Section */
        .assistant-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px dashed var(--border-subtle);
        }

        .assistant-output {
            margin-top: 20px;
            white-space: pre-wrap;
            line-height: 1.6;
            font-size: 0.95rem;
            font-family: var(--font-mono);
            min-height: 180px;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid var(--border-card);
            border-radius: var(--radius-md);
            padding: 20px;
            background: #090a0c;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: var(--border-subtle) transparent;
        }

        .assistant-output::-webkit-scrollbar {
            width: 8px;
        }

        .assistant-output::-webkit-scrollbar-track {
            background: transparent;
        }

        .assistant-output::-webkit-scrollbar-thumb {
            background: var(--border-subtle);
            border-radius: 4px;
        }

        .assistant-output::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Links & Lists (Card Specific) */
        .link-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .link-list a {
            color: var(--accent-cyan);
            text-decoration: none;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .link-list a:hover {
            color: var(--text-main);
        }

        .link-list a::before {
            content: '→';
            opacity: 0.5;
            transition: transform 0.2s;
        }

        .link-list a:hover::before {
            transform: translateX(3px);
            color: var(--accent-cyan);
            opacity: 1;
        }

        /* Ops Alerts List */
        .ops-history {
            margin-top: 16px;
            max-height: 200px;
            overflow-y: auto;
            border-radius: var(--radius-sm);
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-muted);
            word-break: break-word;
            line-height: 1.4;
        }

        @media (max-width: 900px) {
            .grid-middle {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="fileProtocolWarning" class="card"
            style="display:none; border-color: var(--state-warn); margin-bottom: 16px;">
            <h4 class="card-title" style="color: var(--state-warn);">Неверный режим открытия</h4>
            <p class="card-meta">
                Панель открыта как файл (`file://`). Для корректной работы API открой через `http://127.0.0.1:8080`.
            </p>
        </div>

        <header>
            <div class="header-titles">
                <h1>Krab Web Panel V2</h1>
                <p class="subtitle">Nexus Orchestration & Local LM Gateway</p>
            </div>
            <button id="refreshBtn" class="primary" aria-label="Синхронизировать данные">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.13 15.57a10 10 0 1 0 1.95-10.42L2 7" />
                </svg>
                Sync Data
            </button>
        </header>

        <!-- --- METRICS --- -->
        <div class="grid-metrics">
            <div class="card">
                <h3 class="card-title">Система</h3>
                <p class="card-value break-word" id="degradation">—</p>
            </div>
            <div class="card">
                <h3 class="card-title">Black Box</h3>
                <p class="card-value" id="bb_total">—</p>
            </div>
            <div class="card">
                <h3 class="card-title">RAG Docs</h3>
                <p class="card-value" id="rag_total">—</p>
            </div>
            <div class="card">
                <h3 class="card-title">Local Model</h3>
                <p class="card-value break-word" id="local_model">—</p>
            </div>
        </div>

        <!-- --- SERVICES & OPS --- -->
        <div class="grid-middle">
            <div class="form-group" style="gap:20px;">
                <div class="card">
                    <h3 class="card-title">Контекст и Сервисы</h3>
                    <div id="checks" style="margin-bottom:12px;">—</div>
                    <div class="card-meta" id="updated_at">Waiting for sync...</div>
                </div>

                <div class="card">
                    <h3 class="card-title">Рекомендовано</h3>
                    <p class="card-value" id="recommended_model" style="font-size:1.4rem;">—</p>
                    <p class="card-meta" id="recommended_meta"></p>
                </div>

                <div class="card">
                    <h3 class="card-title">Ссылки</h3>
                    <div class="link-list" id="links">
                        <a href="#">OpenClaw Dashboard</a>
                        <a href="#">LM Studio API</a>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3 class="card-title" style="color:var(--state-warn)">Ops Alerts & Guardrails</h3>
                <div id="opsAlerts" class="card-meta">—</div>
                <p class="card-meta" id="opsUsageMeta"></p>

                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-subtle);">
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <input id="opsAlertCode" class="field" placeholder="Alert Code (ex: cloud_share)">
                        <input id="opsAlertNote" class="field" placeholder="Note (opt)">
                    </div>
                    <div style="display: flex; gap:10px;">
                        <button id="opsAckBtn" class="primary">Acknowledge</button>
                        <button id="opsUnackBtn">Revoke Ack</button>
                    </div>
                </div>
                <p class="card-meta" id="opsActionMeta">Управление alert-ами через Web API</p>
                <div id="opsHistory" class="ops-history empty">
                    <div class="empty-state" style="padding: 24px 0;">
                        <svg width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.5"
                            viewBox="0 0 24 24" style="margin-bottom:12px; color: var(--text-placeholder)">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z">
                            </path>
                        </svg>
                        <div style="font-size: 0.85rem">Operations history will appear here.</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- --- OPENCLAW CONTROL CENTER (R9 IDs parity) --- -->
        <div class="card">
            <h3 class="card-title">OpenClaw Control Center</h3>
            <div class="grid-metrics"
                style="grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); margin-bottom: 16px;">
                <div>
                    <div class="card-meta">Force Mode</div>
                    <div class="card-value break-word" id="ocForceMode">—</div>
                </div>
                <div>
                    <div class="card-meta">Local Model</div>
                    <div class="card-value break-word" id="ocLocalModel">—</div>
                </div>
                <div>
                    <div class="card-meta">Cloud Slots</div>
                    <div class="card-value break-word" id="ocCloudSlots">—</div>
                </div>
                <div>
                    <div class="card-meta">Autoswitch</div>
                    <div class="card-value break-word" id="ocAutoswitchStatus">—</div>
                </div>
                <div>
                    <div class="card-meta">Last Switch</div>
                    <div class="card-value break-word" id="ocLastSwitch">—</div>
                </div>
                <div>
                    <div class="card-meta">Switch Reason</div>
                    <div class="card-value break-word" id="ocSwitchReason">—</div>
                </div>
            </div>

            <div id="ocChannelsList" class="ops-history empty">
                <div class="empty-state" style="padding: 16px 0;">
                    Каналы будут отображены после обновления статуса.
                </div>
            </div>

            <div class="card" style="margin-top: 16px;">
                <h4 class="card-title">Local Model Lifecycle</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <div>
                        <div class="card-meta">Status</div>
                        <div id="ocLocalLifecycleStatus" class="card-value break-word">—</div>
                    </div>
                    <div>
                        <div class="card-meta">Model</div>
                        <div id="ocLocalLifecycleModel" class="card-value break-word">—</div>
                    </div>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px;">
                    <button id="ocLocalLoadBtn">Load Local</button>
                    <button id="ocLocalUnloadBtn">Unload Local</button>
                    <button id="ocLocalRefreshBtn">Refresh Local Status</button>
                </div>
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 16px;">
                <button id="ocApplyAutoswitchBtn" class="primary">Apply Autoswitch</button>
                <button id="ocModeLocalBtn">Set Local</button>
                <button id="ocModeAutoBtn">Set Auto</button>
                <button id="ocModeCloudBtn">Set Cloud</button>
                <button id="ocRefreshBtn">Refresh Status</button>
            </div>
            <p id="ocMeta" class="card-meta" style="margin-top: 10px;">OpenClaw panel ready.</p>
        </div>

        <!-- --- AI ASSISTANT --- -->
        <div class="card" style="border-top: 2px solid var(--accent-cyan); padding: 32px;">
            <h3 class="card-title" style="margin-bottom:24px; color:var(--text-main); font-size:1.1rem;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    style="color:var(--accent-cyan);">
                    <path d="M12 2v20M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" />
                </svg>
                AI Assistant Interface
            </h3>

            <!-- AI Engine Config -->
            <div class="form-grid">
                <div class="form-group">
                    <span class="form-label">Режим Роутинга</span>
                    <select id="modelModeSelect" class="field">
                        <option value="auto">Auto (Local-First)</option>
                        <option value="local">Local (Force)</option>
                        <option value="cloud">Cloud (Force)</option>
                    </select>
                </div>
                <div class="form-group">
                    <span class="form-label">Пресет</span>
                    <select id="modelPresetSelect" class="field">
                        <option value="balanced_auto">Balanced Auto</option>
                        <option value="local_focus">Local Focus</option>
                        <option value="cloud_reasoning">Cloud Reasoning</option>
                    </select>
                </div>
                <div class="form-group">
                    <span class="form-label">Слот / Модель</span>
                    <div style="display:flex; gap:8px;">
                        <select id="modelSlotSelect" class="field" style="flex:1;">
                            <option value="chat">Chat</option>
                        </select>
                        <select id="modelChoiceSelect" class="field" style="flex:2;">
                            <option value="google/gemini-2.5-flash">gemini-2.5-flash</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="assistant-actions">
                <button id="modelCatalogReloadBtn">Reload Catalog</button>
                <button id="modelApplyModeBtn">Apply Mode</button>
                <button id="modelApplyPresetBtn">Apply Preset</button>
                <button id="modelApplySlotBtn">Save Slot</button>
                <span class="card-meta" id="modelControlMeta" style="margin-left: auto;">Model catalog loaded.</span>
            </div>

            <!-- Task Parameters -->
            <div class="form-grid"
                style="margin-top:24px; padding-top:24px; border-top: 1px solid var(--border-subtle);">
                <div class="form-group">
                    <span class="form-label">Тип Задачи</span>
                    <select id="assistantTaskType" class="field">
                        <option value="chat">Chat</option>
                        <option value="reasoning">Reasoning</option>
                        <option value="coding">Coding</option>
                        <option value="review">Review</option>
                    </select>
                </div>
                <div class="form-group">
                    <span class="form-label">Глубина</span>
                    <select id="assistantReasoningDepth" class="field">
                        <option value="auto">Auto</option>
                        <option value="fast">Fast</option>
                        <option value="deep">Deep</option>
                    </select>
                </div>
                <div class="form-group">
                    <span class="form-label">RAG Контекст</span>
                    <select id="assistantUseRag" class="field">
                        <option value="off">Off</option>
                        <option value="on">On</option>
                    </select>
                </div>
                <div class="form-group">
                    <span class="form-label">API Key</span>
                    <input id="assistantApiKey" class="field" placeholder="API Key (optional)">
                </div>
            </div>

            <textarea id="assistantPrompt" class="field"
                placeholder="Enter task, prompt, or code snippet here..."></textarea>

            <div class="assistant-actions" style="margin-top:16px;">
                <button id="assistantRunBtn" class="primary" aria-label="Запустить ассистента">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3" />
                    </svg>
                    Run Assistant
                </button>
                <button id="assistantPlanBtn" aria-label="Собрать preflight-план">Preflight Plan</button>
                <span class="card-meta" id="assistantMeta" style="margin-left:auto;">Ready for execution</span>
            </div>

            <div id="assistantOutput" class="assistant-output empty">
                <div class="empty-state" style="height: 100%;">
                    <svg width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"
                        style="margin-bottom:16px; color: var(--text-placeholder)">
                        <path stroke-linecap="round" stroke-linejoin="round"
                            d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z">
                        </path>
                    </svg>
                    <div style="font-weight: 500; color: var(--text-main); margin-bottom: 8px;">Awaiting Input</div>
                    <div style="font-size: 0.9rem">Run assistant or use quick tools to generate content.</div>
                </div>
            </div>

            <!-- Quick Actions Tools -->
            <div style="margin-top:32px;">
                <h4 class="form-label" style="margin-bottom:12px; font-size:0.9rem;">Quick Utilities</h4>
                <div class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));">
                    <div class="form-group">
                        <input id="quickWebQuery" class="field" placeholder="Web search query...">
                        <button id="quickWebBtn" style="width:100%;" aria-label="Искать в вебе">Search</button>
                    </div>
                    <div class="form-group">
                        <input id="quickDeepTopic" class="field" placeholder="Deep research topic...">
                        <button id="quickDeepBtn" style="width:100%;" aria-label="Начать глубокое исследование">Deep
                            Research</button>
                    </div>
                    <div class="form-group">
                        <input id="quickSourceUrl" class="field" placeholder="URL for context...">
                        <button id="quickUrlBtn" style="width:100%;" aria-label="Анализировать ссылку">Analyze
                            URL</button>
                    </div>
                    <div class="form-group">
                        <input id="assistantFileInput" class="field" type="file" style="padding: 6px;"
                            aria-label="Выбрать файл для загрузки">
                        <button id="assistantAttachBtn" style="width:100%;" aria-label="Прикрепить файл">Attach
                            File</button>
                    </div>
                </div>
                <p class="card-meta" id="quickActionMeta">Use quick tools to automatically generate tailored prompts.
                </p>
            </div>

            <!-- Feedback -->
            <div class="form-grid"
                style="margin-top:24px; padding-top:24px; border-top: 1px solid var(--border-card); grid-template-columns: 80px 140px 1fr auto auto; align-items: center; gap: 8px;">
                <input id="feedbackScore" class="field" type="number" min="1" max="5" value="5" placeholder="1-5">
                <input id="feedbackProfile" class="field" placeholder="Profile (opt)">
                <input id="feedbackNote" class="field" placeholder="Feedback notes...">
                <button id="feedbackSendBtn" class="primary">Submit Feedback</button>
                <button id="feedbackStatsBtn">Show Stats</button>
            </div>
            <p class="card-meta" id="feedbackMeta">Score is applied to the latest engine run profile.</p>

        </div>
    </div>

    <!-- Legacy API JS integration stays intact to ensure 0 regression with the backend -->
    <script>
        if (window.location.protocol === 'file:') {
            const warnBanner = document.getElementById('fileProtocolWarning');
            if (warnBanner) warnBanner.style.display = 'block';
        }
        function badge(ok, label) {
            const cls = ok ? 'ok' : 'warn';
            return `<span class="badge ${cls}">${ok ? 'ON' : 'OFF'} ${label}</span>`;
        }

        function setText(id, value) {
            const node = document.getElementById(id);
            if (node) node.textContent = value;
        }

        async function fetchJson(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        }

        function readWebApiKey() {
            return (document.getElementById('assistantApiKey').value || '').trim();
        }

        async function postJson(url, body, withKey = true, method = 'POST') {
            const headers = { 'Content-Type': 'application/json' };
            if (withKey) {
                const webApiKey = readWebApiKey();
                if (webApiKey) {
                    headers['X-Krab-Web-Key'] = webApiKey;
                }
            }
            const response = await fetch(url, {
                method,
                headers,
                body: method === 'DELETE' ? undefined : JSON.stringify(body || {})
            });
            const payload = await response.json();
            if (!response.ok) {
                throw new Error(payload?.detail || `HTTP ${response.status}`);
            }
            return payload;
        }

        function withBtnState(btnId, loadingText, fetchPromiseFn) {
            return async (e) => {
                const btn = document.getElementById(btnId);
                const isInput = btn && btn.nodeName === 'INPUT';
                const origText = btn ? (isInput ? btn.value : btn.innerHTML) : "";
                if (btn) {
                    btn.disabled = true;
                    if (loadingText) {
                        if (isInput) btn.value = loadingText;
                        else btn.innerHTML = loadingText;
                    }
                }
                try {
                    await fetchPromiseFn(e);
                } finally {
                    if (btn) {
                        btn.disabled = false;
                        if (loadingText) {
                            if (isInput) btn.value = origText;
                            else btn.innerHTML = origText;
                        }
                    }
                }
            };
        }

        let modelCatalogState = null;

        function normalizedForceMode(rawMode) {
            const normalized = String(rawMode || '').trim().toLowerCase();
            if (normalized === 'force_local' || normalized === 'local') return 'local';
            if (normalized === 'force_cloud' || normalized === 'cloud') return 'cloud';
            return 'auto';
        }

        function fillSelect(nodeId, options, selectedValue = '') {
            const node = document.getElementById(nodeId);
            if (!node) return;
            const current = String(selectedValue || '');
            const html = options.map((item) => {
                const value = String(item.value ?? '');
                const label = String(item.label ?? value);
                const selected = value === current ? ' selected' : '';
                return `<option value="${value}"${selected}>${label}</option>`;
            }).join('');
            node.innerHTML = html || '<option value="">(пусто)</option>';
        }

        function getModelOptionsFromCatalog(catalog) {
            const result = [];
            const localModels = Array.isArray(catalog?.local_models) ? catalog.local_models : [];
            const cloudPresets = Array.isArray(catalog?.cloud_presets) ? catalog.cloud_presets : [];
            const cloudSlots = catalog?.cloud_slots || {};

            for (const item of localModels) {
                const modelId = String(item?.id || '').trim();
                if (!modelId) continue;
                const loadedSuffix = item?.loaded ? ' • loaded' : '';
                const sizeSuffix = item?.size_human ? ` • ${item.size_human}` : '';
                result.push({
                    value: modelId,
                    label: `LOCAL • ${modelId}${loadedSuffix}${sizeSuffix}`,
                });
            }

            for (const item of cloudPresets) {
                const modelId = String(item?.id || '').trim();
                if (!modelId) continue;
                result.push({
                    value: modelId,
                    label: `CLOUD • ${modelId}`,
                });
            }

            for (const modelId of Object.values(cloudSlots)) {
                const text = String(modelId || '').trim();
                if (!text) continue;
                result.push({
                    value: text,
                    label: `CURRENT • ${text}`,
                });
            }

            const dedup = [];
            const seen = new Set();
            for (const item of result) {
                if (seen.has(item.value)) continue;
                seen.add(item.value);
                dedup.push(item);
            }
            return dedup;
        }

        function syncSlotModelSelection() {
            const slotNode = document.getElementById('modelSlotSelect');
            const modelNode = document.getElementById('modelChoiceSelect');
            if (!slotNode || !modelNode || !modelCatalogState) return;
            const slot = String(slotNode.value || '').trim();
            const currentModel = String((modelCatalogState.cloud_slots || {})[slot] || '').trim();
            if (!currentModel) return;
            const found = Array.from(modelNode.options).some((option) => option.value === currentModel);
            if (found) {
                modelNode.value = currentModel;
            }
        }

        function syncModelControls(catalog) {
            modelCatalogState = catalog || {};
            const mode = normalizedForceMode(catalog?.force_mode);
            const slotNames = Array.isArray(catalog?.slots) ? catalog.slots : [];
            const quickPresets = Array.isArray(catalog?.quick_presets) ? catalog.quick_presets : [];
            const selectedSlot = String(document.getElementById('modelSlotSelect')?.value || '');

            fillSelect(
                'modelModeSelect',
                [
                    { value: 'auto', label: 'auto (local-first)' },
                    { value: 'local', label: 'local (force_local)' },
                    { value: 'cloud', label: 'cloud (force_cloud)' },
                ],
                mode
            );
            fillSelect(
                'modelPresetSelect',
                quickPresets.length
                    ? quickPresets.map((item) => ({
                        value: item.id,
                        label: `${item.title} — ${item.description}`,
                    }))
                    : [{ value: 'balanced_auto', label: 'Balanced Auto' }],
                String(document.getElementById('modelPresetSelect')?.value || 'balanced_auto')
            );
            fillSelect(
                'modelSlotSelect',
                slotNames.length
                    ? slotNames.map((slot) => ({ value: slot, label: slot }))
                    : [{ value: 'chat', label: 'chat' }],
                selectedSlot && slotNames.includes(selectedSlot) ? selectedSlot : (slotNames[0] || 'chat')
            );

            const modelOptions = getModelOptionsFromCatalog(catalog);
            fillSelect(
                'modelChoiceSelect',
                modelOptions.length ? modelOptions : [{ value: '', label: '(модели не обнаружены)' }],
                ''
            );
            syncSlotModelSelection();

            const localState = catalog?.local_available ? 'local=online' : 'local=offline';
            const active = catalog?.local_active_model ? ` • active=${catalog.local_active_model}` : '';
            setText('modelControlMeta', `Каталог обновлен • mode=${mode} • ${localState}${active}`);
        }

        async function loadModelCatalog(showStatus = true) {
            try {
                const payload = await fetchJson('/api/model/catalog');
                if (!payload?.ok) {
                    throw new Error(payload?.error || 'model_catalog_failed');
                }
                syncModelControls(payload.catalog || {});
                if (showStatus) {
                    setText('modelControlMeta', 'Каталог моделей готов.');
                }
            } catch (error) {
                setText('modelControlMeta', `Ошибка каталога моделей: ${error.message}`);
            }
        }

        async function applyModelAction(action, extraPayload = {}) {
            try {
                setText('modelControlMeta', 'Применяю изменения...');
                const payload = await postJson('/api/model/apply', { action, ...extraPayload }, true, 'POST');
                if (!payload?.ok) {
                    throw new Error(payload?.error || 'model_apply_failed');
                }
                syncModelControls(payload.catalog || {});
                if (payload.message) {
                    document.getElementById('assistantOutput').textContent = String(payload.message);
                }
                setText('modelControlMeta', payload.message || 'Изменения применены.');
                await updateStats();
            } catch (error) {
                setText('modelControlMeta', `Ошибка применения: ${error.message}`);
            }
        }

        function appendPromptChunk(chunk) {
            const node = document.getElementById('assistantPrompt');
            const existing = String(node.value || '').trim();
            const incoming = String(chunk || '').trim();
            if (!incoming) return;
            node.value = existing ? `${existing}\n\n${incoming}` : incoming;
        }

        async function attachSelectedFileToPrompt() {
            const input = document.getElementById('assistantFileInput');
            const files = input?.files || [];
            if (!files.length) {
                setText('quickActionMeta', 'Выбери файл перед добавлением в prompt.');
                return;
            }
            const file = files[0];
            try {
                setText('quickActionMeta', `Загружаю файл: ${file.name}...`);
                const formData = new FormData();
                formData.append('file', file);

                const headers = {};
                const webApiKey = readWebApiKey();
                if (webApiKey) {
                    headers['X-Krab-Web-Key'] = webApiKey;
                }

                const response = await fetch('/api/assistant/attachment', {
                    method: 'POST',
                    headers,
                    body: formData,
                });
                const payload = await response.json();
                if (!response.ok) {
                    throw new Error(payload?.detail || `HTTP ${response.status}`);
                }
                const attachment = payload?.attachment || {};
                appendPromptChunk(String(attachment.prompt_snippet || ''));
                setText(
                    'quickActionMeta',
                    `Файл добавлен: ${attachment.file_name || file.name} • ${attachment.kind || 'attachment'}`
                );
            } catch (error) {
                setText('quickActionMeta', `Ошибка загрузки файла: ${error.message}`);
            }
        }

        async function runQuickWebSearch() {
            const query = (document.getElementById('quickWebQuery').value || '').trim();
            if (!query) {
                setText('quickActionMeta', 'Введи запрос для web-search.');
                return;
            }
            document.getElementById('assistantTaskType').value = 'chat';
            document.getElementById('assistantReasoningDepth').value = 'balanced';
            appendPromptChunk(
                `Сделай web-search по теме: "${query}".
Нужен краткий отчет: ключевые факты, 3-5 надежных источников и практические выводы.`
            );
            setText('quickActionMeta', 'Шаблон web-search подготовлен. Запускаю...');
            await assistantQuery();
        }

        async function runQuickDeepResearch() {
            const topic = (document.getElementById('quickDeepTopic').value || '').trim();
            if (!topic) {
                setText('quickActionMeta', 'Введи тему для deep research.');
                return;
            }
            document.getElementById('assistantTaskType').value = 'reasoning';
            document.getElementById('assistantReasoningDepth').value = 'deep';
            appendPromptChunk(
                `Deep research по теме: "${topic}".
Собери структурированный отчет:
1) краткое резюме,
2) ключевые риски/возможности,
3) сравнение подходов,
4) пошаговый план действий,
5) ссылки на проверяемые источники.`
            );
            setText('quickActionMeta', 'Шаблон deep research подготовлен. Запускаю...');
            await assistantQuery();
        }

        async function runQuickUrlReview() {
            const sourceUrl = (document.getElementById('quickSourceUrl').value || '').trim();
            if (!sourceUrl) {
                setText('quickActionMeta', 'Введи URL для разбора.');
                return;
            }
            document.getElementById('assistantTaskType').value = 'reasoning';
            document.getElementById('assistantReasoningDepth').value = 'balanced';
            appendPromptChunk(
                `Разбери материал по ссылке: ${sourceUrl}
Нужно:
- краткое содержание;
- ключевые тезисы/факты;
- что это значит practically для меня;
- если это YouTube: выдели главные выводы и тайм-коды (если доступны).`
            );
            setText('quickActionMeta', 'Шаблон URL-анализа подготовлен. Запускаю...');
            await assistantQuery();
        }

        async function opsAckAction(isAck) {
            const code = (document.getElementById('opsAlertCode').value || '').trim();
            const note = (document.getElementById('opsAlertNote').value || '').trim();
            if (!code) {
                setText('opsActionMeta', 'Ошибка: укажи alert code');
                return;
            }
            setText('opsActionMeta', `${isAck ? 'Ack' : 'Unack'} в процессе...`);
            try {
                if (isAck) {
                    await postJson(`/api/ops/ack/${encodeURIComponent(code)}`, { actor: 'web_panel', note });
                    setText('opsActionMeta', `OK: alert ${code} подтвержден`);
                } else {
                    await postJson(`/api/ops/ack/${encodeURIComponent(code)}`, {}, true, 'DELETE');
                    setText('opsActionMeta', `OK: alert ${code} снят с подтверждения`);
                }
                await updateStats();
            } catch (error) {
                setText('opsActionMeta', `Ошибка: ${error.message}`);
            }
        }

        async function assistantQuery() {
            const prompt = (document.getElementById('assistantPrompt').value || '').trim();
            const taskTypeRaw = (document.getElementById('assistantTaskType').value || 'chat').trim();
            const depthRaw = (document.getElementById('assistantReasoningDepth').value || 'auto').trim().toLowerCase();
            const ragRaw = (document.getElementById('assistantUseRag').value || 'off').trim().toLowerCase();
            const webApiKey = (document.getElementById('assistantApiKey').value || '').trim();
            let taskType = taskTypeRaw || 'chat';
            const confirmExpensive = depthRaw === 'deep';

            // UX: depth=deep автоматически переводит chat -> reasoning.
            if (taskType === 'chat' && depthRaw === 'deep') {
                taskType = 'reasoning';
            }

            if (!prompt) {
                setText('assistantMeta', 'Ошибка: пустой prompt');
                return;
            }

            const useRag = ['1', 'on', 'true', 'yes', 'y'].includes(ragRaw);
            const headers = { 'Content-Type': 'application/json' };
            if (webApiKey) {
                headers['X-Krab-Web-Key'] = webApiKey;
            }

            setText('assistantMeta', 'Выполняю запрос...');
            document.getElementById('assistantOutput').textContent = '⏳ Выполнение...';

            try {
                const response = await fetch('/api/assistant/query', {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({
                        prompt,
                        task_type: taskType || 'chat',
                        use_rag: useRag,
                        confirm_expensive: confirmExpensive
                    })
                });
                const payload = await response.json();
                if (!response.ok) {
                    throw new Error(payload?.detail || `HTTP ${response.status}`);
                }

                document.getElementById('assistantOutput').textContent = payload.reply || '(пустой ответ)';
                setText(
                    'assistantMeta',
                    `OK • профиль: ${payload.profile || '-'} • task: ${payload.task_type || '-'} • depth: ${depthRaw}`
                );
                const lastRoute = payload.last_route || {};
                if (lastRoute.profile) {
                    document.getElementById('feedbackProfile').value = String(lastRoute.profile);
                }
                if (lastRoute.model || lastRoute.channel) {
                    setText(
                        'feedbackMeta',
                        `Последний прогон: ${lastRoute.model || '-'} (${lastRoute.channel || '-'})`
                    );
                }
            } catch (error) {
                document.getElementById('assistantOutput').textContent = `Ошибка: ${error.message}`;
                setText('assistantMeta', 'Запрос завершился с ошибкой');
            }
        }

        async function assistantPreflight() {
            const prompt = (document.getElementById('assistantPrompt').value || '').trim();
            const taskTypeRaw = (document.getElementById('assistantTaskType').value || 'chat').trim();
            const depthRaw = (document.getElementById('assistantReasoningDepth').value || 'auto').trim().toLowerCase();
            const webApiKey = (document.getElementById('assistantApiKey').value || '').trim();
            const selectedModel = (document.getElementById('modelChoiceSelect').value || '').trim();
            let taskType = taskTypeRaw || 'chat';
            const confirmExpensive = depthRaw === 'deep';

            if (taskType === 'chat' && depthRaw === 'deep') {
                taskType = 'reasoning';
            }

            if (!prompt) {
                setText('assistantMeta', 'Ошибка: пустой prompt');
                return;
            }

            const headers = { 'Content-Type': 'application/json' };
            if (webApiKey) {
                headers['X-Krab-Web-Key'] = webApiKey;
            }

            setText('assistantMeta', 'Собираю preflight-план...');
            document.getElementById('assistantOutput').textContent = '⏳ Анализ маршрута...';

            try {
                const response = await fetch('/api/model/preflight', {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({
                        prompt,
                        task_type: taskType || 'chat',
                        preferred_model: selectedModel || null,
                        confirm_expensive: confirmExpensive
                    })
                });
                const payload = await response.json();
                if (!response.ok) {
                    throw new Error(payload?.detail || `HTTP ${response.status}`);
                }
                if (!payload?.ok) {
                    throw new Error(payload?.error || 'preflight_failed');
                }

                const plan = payload.preflight || {};
                const execution = plan.execution || {};
                const warnings = plan.warnings || [];
                const reasons = plan.reasons || [];
                const warningText = warnings.length ? warnings.map((item) => `- ${item}`).join('\n') : '- нет';
                const reasonText = reasons.length ? reasons.map((item) => `- ${item}`).join('\n') : '- нет';

                document.getElementById('assistantOutput').textContent =
                    `Preflight:
task_type=${plan.task_type || '-'}
profile=${plan.profile || '-'}
critical=${plan.critical ? 'yes' : 'no'}
channel=${execution.channel || '-'}
model=${execution.model || '-'}
can_run_now=${execution.can_run_now ? 'yes' : 'no'}
requires_confirm=${execution.requires_confirm_expensive ? 'yes' : 'no'}
marginal_cost_usd=${plan.cost_hint?.marginal_call_cost_usd ?? 0}

reasons:
${reasonText}

warnings:
${warningText}

next_step: ${plan.next_step || 'Можно запускать задачу.'}`;
                setText(
                    'assistantMeta',
                    `Preflight OK • профиль: ${plan.profile || '-'} • канал: ${execution.channel || '-'} • depth: ${depthRaw}`
                );
            } catch (error) {
                document.getElementById('assistantOutput').textContent = `Ошибка preflight: ${error.message}`;
                setText('assistantMeta', 'Preflight завершился с ошибкой');
            }
        }

        async function submitModelFeedback() {
            const scoreRaw = (document.getElementById('feedbackScore').value || '').trim();
            const profileRaw = (document.getElementById('feedbackProfile').value || '').trim();
            const noteRaw = (document.getElementById('feedbackNote').value || '').trim();
            const score = Number.parseInt(scoreRaw, 10);

            if (!Number.isInteger(score) || score < 1 || score > 5) {
                setText('feedbackMeta', 'Ошибка: score должен быть от 1 до 5');
                return;
            }

            setText('feedbackMeta', 'Сохраняю feedback...');
            try {
                const payload = { score, note: noteRaw };
                if (profileRaw) {
                    payload.profile = profileRaw.toLowerCase();
                }
                const response = await postJson('/api/model/feedback', payload, true, 'POST');
                if (!response?.ok) {
                    throw new Error(response?.error || 'feedback_submit_failed');
                }

                const result = response.result || {};
                setText(
                    'feedbackMeta',
                    `OK: ${result.model || '-'} (${result.profile || '-'}) → ${result.profile_model_stats?.avg ?? 0}/5`
                );
            } catch (error) {
                setText('feedbackMeta', `Ошибка feedback: ${error.message}`);
            }
        }

        async function loadModelFeedbackStats() {
            const profileRaw = (document.getElementById('feedbackProfile').value || '').trim();
            const query = profileRaw ? `?profile=${encodeURIComponent(profileRaw.toLowerCase())}&top=5` : '?top=5';
            setText('feedbackMeta', 'Загружаю feedback-статистику...');

            try {
                const payload = await fetchJson(`/api/model/feedback${query}`);
                if (!payload?.ok) {
                    throw new Error(payload?.error || 'feedback_summary_failed');
                }
                const feedback = payload.feedback || {};
                const models = feedback.top_models || [];
                const channels = feedback.top_channels || [];
                const modelsText = models.length
                    ? models.map((item) => `- ${item.model} (${item.profile}): ${item.avg_score}/5, n=${item.count}`).join('\n')
                    : '- нет данных';
                const channelsText = channels.length
                    ? channels.map((item) => `- ${item.channel}: ${item.avg_score}/5, n=${item.count}`).join('\n')
                    : '- нет данных';
                document.getElementById('assistantOutput').textContent =
                    `Feedback summary:
profile=${feedback.profile || 'all'}
total_feedback=${feedback.total_feedback || 0}

top models:
${modelsText}

top channels:
${channelsText}`;
                setText('feedbackMeta', `Feedback loaded • total=${feedback.total_feedback || 0}`);
            } catch (error) {
                setText('feedbackMeta', `Ошибка feedback stats: ${error.message}`);
            }
        }

        async function updateStats() {
            try {
                const [stats, health, links, recommend, feedbackPayload, usagePayload, alertsPayload, historyPayload] = await Promise.all([
                    fetchJson('/api/stats'),
                    fetchJson('/api/health'),
                    fetchJson('/api/links'),
                    fetchJson('/api/model/recommend?profile=chat'),
                    fetchJson('/api/model/feedback?profile=chat&top=1'),
                    fetchJson('/api/ops/usage'),
                    fetchJson('/api/ops/alerts'),
                    fetchJson('/api/ops/history?limit=8')
                ]);

                const bb = stats.black_box || {};
                const rag = stats.rag || {};
                const router = stats.router || {};

                setText('bb_total', String(bb.total ?? bb.total_messages ?? 0));
                setText('rag_total', String(rag.count ?? 0));
                setText('local_model', router.local_model || 'Offline');
                setText('degradation', health.degradation || 'unknown');

                const checks = health.checks || {};
                document.getElementById('checks').innerHTML =
                    badge(!!checks.openclaw, 'OpenClaw') +
                    badge(!!checks.local_lm, 'Local LM') +
                    badge(!!checks.voice_gateway, 'Voice Gateway') +
                    badge(!!checks.krab_ear, 'Krab Ear');

                const linksBlock = [
                    ['Dashboard', links.dashboard],
                    ['Stats API', links.stats_api],
                    ['Health API', links.health_api],
                    ['Ecosystem Health API', links.ecosystem_health_api],
                    ['Model Preflight API', `${links.dashboard}/api/model/preflight`],
                    ['Model Feedback API', `${links.dashboard}/api/model/feedback`],
                    ['OpenClaw Deep Check', `${links.dashboard}/api/openclaw/deep-check`],
                    ['OpenClaw Remediation Plan', `${links.dashboard}/api/openclaw/remediation-plan`],
                    ['OpenClaw Browser Smoke', `${links.dashboard}/api/openclaw/browser-smoke`],
                    ['Assistant Capabilities', `${links.dashboard}/api/assistant/capabilities`],
                    ['Ops Cost Report', `${links.dashboard}/api/ops/cost-report`],
                    ['Ops Executive Summary', `${links.dashboard}/api/ops/executive-summary`],
                    ['Ops Full Report', `${links.dashboard}/api/ops/report`],
                    ['Ops Bundle Export', `${links.dashboard}/api/ops/bundle/export`],
                    ['OpenClaw', links.openclaw],
                    ['Voice Gateway', links.voice_gateway],
                ].filter(([, url]) => !!url)
                    .map(([name, url]) => `<a href="${url}" target="_blank" rel="noreferrer">${name}: ${url}</a>`)
                    .join('');
                document.getElementById('links').innerHTML = linksBlock || '—';

                setText('recommended_model', recommend.model || '—');
                const bestFeedback = feedbackPayload?.feedback?.top_models?.[0] || null;
                if (bestFeedback) {
                    setText(
                        'recommended_meta',
                        `Профиль: ${recommend.profile || 'chat'} • Канал: ${recommend.channel || 'auto'} • Quality: ${bestFeedback.avg_score}/5 (n=${bestFeedback.count})`
                    );
                } else {
                    setText('recommended_meta', `Профиль: ${recommend.profile || 'chat'} • Канал: ${recommend.channel || 'auto'}`);
                }

                const usage = usagePayload.usage || {};
                const totals = usage.totals || {};
                const ratios = usage.ratios || {};
                const softCap = usage.soft_cap || {};
                setText(
                    'opsUsageMeta',
                    `Calls: total=${totals.all_calls ?? 0}, cloud=${totals.cloud_calls ?? 0}, local=${totals.local_calls ?? 0} • cloud_share=${ratios.cloud_share ?? 0} • cap_left=${softCap.cloud_remaining_calls ?? 0}`
                );

                const alertsRoot = alertsPayload.alerts || {};
                const alertsList = alertsRoot.alerts || [];
                if (!alertsList.length) {
                    document.getElementById('opsAlerts').innerHTML = '<span class="badge ok">OK no active alerts</span>';
                } else {
                    const html = alertsList
                        .map((item) => {
                            const ack = item.acknowledged ? ` <span class="badge ok">ACK ${item.ack?.actor || ''}</span>` : '';
                            return `<div><span class="badge ${item.severity === 'high' ? 'bad' : 'warn'}">${item.severity || 'info'}</span> ${item.code || ''} — ${item.message || ''}${ack}</div>`;
                        })
                        .join('');
                    document.getElementById('opsAlerts').innerHTML = html;
                }

                const history = historyPayload.history?.items || [];
                if (!history.length) {
                    document.getElementById('opsHistory').innerHTML = '<div class="empty-state" style="padding: 24px 0;"><svg width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24" style="margin-bottom:12px; color: var(--text-placeholder)"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z"></path></svg><div style="font-size: 0.85rem">История ops: пусто</div></div>';
                    document.getElementById('opsHistory').classList.add('empty');
                } else {
                    document.getElementById('opsHistory').classList.remove('empty');
                    document.getElementById('opsHistory').innerHTML = history
                        .map((item) => `${item.ts || '-'} • ${item.status || '-'} • alerts=${item.alerts_count ?? 0} • codes=${(item.codes || []).join(',') || '-'}`)
                        .join('<br>');
                }
                setText('updated_at', `Обновлено: ${new Date().toLocaleTimeString()}`);
            } catch (error) {
                console.error('Stats update failed', error);
                setText('updated_at', `Ошибка обновления: ${error.message}`);
            }
        }

        async function loadOpenclawStatus(showStatus = true) {
            try {
                if (showStatus) setText('ocMeta', 'Загружаю статус OpenClaw...');

                const [catalogRes, autoswitchRes, channelsRes] = await Promise.all([
                    fetch('/api/model/catalog').catch((e) => ({ ok: false, error: e.message })),
                    fetch('/api/openclaw/model-autoswitch/status').catch((e) => ({ ok: false, error: e.message })),
                    fetch('/api/openclaw/channels/status').catch((e) => ({ ok: false, error: e.message }))
                ]);

                // Catalog processing
                if (catalogRes.ok) {
                    const payload = await catalogRes.json();
                    setText('ocForceMode', payload.catalog?.force_mode || 'auto');
                    setText('ocLocalModel', payload.catalog?.local_active_model || 'offline');
                    const slots = Object.keys(payload.catalog?.cloud_slots || {}).length;
                    setText('ocCloudSlots', slots > 0 ? `${slots} active` : 'none');
                } else {
                    setText('ocForceMode', 'ERR');
                    setText('ocLocalModel', 'ERR');
                    setText('ocCloudSlots', 'ERR');
                }

                // Autoswitch processing
                if (autoswitchRes.ok) {
                    const payload = await autoswitchRes.json();
                    const st = payload.status || 'unknown';
                    const badgeClass = (st.toUpperCase() === 'ACTIVE' || st.toUpperCase() === 'OK' || st.toUpperCase() === 'ON') ? 'ok' : (st.toUpperCase() === 'FAIL' || st.toUpperCase() === 'ERROR' ? 'bad' : 'warn');
                    document.getElementById('ocAutoswitchStatus').innerHTML = `<span class="badge ${badgeClass}">${st}</span>`;
                    setText('ocLastSwitch', payload.last_switch || '-');
                    setText('ocSwitchReason', payload.reason || '-');
                } else {
                    const errPayload = autoswitchRes.json ? await autoswitchRes.json().catch(() => ({})) : {};
                    const errText = errPayload.detail || autoswitchRes.error || `HTTP ${autoswitchRes.status}`;
                    document.getElementById('ocAutoswitchStatus').innerHTML = `<span class="badge bad">ERR: ${errText}</span>`;
                    setText('ocLastSwitch', '-');
                    setText('ocSwitchReason', '-');
                }

                // Channels processing
                if (channelsRes.ok) {
                    const payload = await channelsRes.json();
                    const channels = payload.channels || [];
                    if (channels.length === 0) {
                        document.getElementById('ocChannelsList').innerHTML = '<span class="card-meta">No channels data</span>';
                    } else {
                        document.getElementById('ocChannelsList').innerHTML = channels.map(c => {
                            const badgeClass = c.status === 'OK' ? 'ok' : (c.status === 'FAIL' ? 'bad' : 'warn');
                            return `<div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="card-meta">${c.name || 'channel'}</span>
                                <span class="badge ${badgeClass}">${c.status}</span>
                            </div>`;
                        }).join('');
                    }
                } else {
                    const errPayload = channelsRes.json ? await channelsRes.json().catch(() => ({})) : {};
                    const errText = errPayload.detail || channelsRes.error || `HTTP ${channelsRes.status}`;
                    document.getElementById('ocChannelsList').innerHTML = `<span class="card-meta" style="color:var(--state-error)">Error: ${errText}</span>`;
                }

                if (showStatus) setText('ocMeta', 'Статус обновлен');
            } catch (error) {
                setText('ocMeta', `Ошибка API: ${error.message}`);
            }
        }

        async function ocApplyAutoswitch() {
            try {
                setText('ocMeta', 'Applying autoswitch...');
                const payload = await postJson('/api/openclaw/model-autoswitch/apply', { toggle: true });
                setText('ocMeta', payload.message || 'Autoswitch applied');
                await loadOpenclawStatus(false);
            } catch (error) {
                setText('ocMeta', `Autoswitch Error: ${error.message}`);
            }
        }

        async function ocApplyMode(mode) {
            try {
                setText('ocMeta', `Setting mode ${mode}...`);
                await applyModelAction('set_mode', { mode });
                setText('ocMeta', `Mode ${mode} applied`);
                await loadOpenclawStatus(false);
            } catch (error) {
                setText('ocMeta', `Mode Error: ${error.message}`);
            }
        }

        async function loadLocalLifecycleStatus(showStatus = true) {
            try {
                if (showStatus) setText('ocMeta', 'Загружаю статус local model...');
                const response = await fetch('/api/model/local/status');
                const payload = await response.json().catch(() => ({}));

                if (!response.ok) {
                    throw new Error(payload.detail || payload.error || `HTTP ${response.status}`);
                }

                const status = payload.status || 'unknown';
                const badgeClass = status === 'loaded' ? 'ok' : (status === 'not_loaded' ? 'warn' : 'bad');
                document.getElementById('ocLocalLifecycleStatus').innerHTML = `<span class="badge ${badgeClass}">${status}</span>`;
                document.getElementById('ocLocalLifecycleModel').textContent = payload.model_name || '-';

                if (showStatus) setText('ocMeta', 'Статус local model обновлен');
            } catch (error) {
                document.getElementById('ocLocalLifecycleStatus').innerHTML = `<span class="badge bad">ERR</span>`;
                document.getElementById('ocLocalLifecycleModel').textContent = '-';
                setText('ocMeta', `Local Status Error: ${error.message}`);
            }
        }

        async function ocLoadLocal() {
            try {
                setText('ocMeta', 'Загрузка local model...');
                await postJson('/api/model/local/load-default', {}, true, 'POST');
                setText('ocMeta', 'Local model загружена');
                await loadLocalLifecycleStatus(false);
            } catch (error) {
                setText('ocMeta', `Load Local Error: ${error.message}`);
            }
        }

        async function ocUnloadLocal() {
            try {
                setText('ocMeta', 'Выгрузка local model...');
                await postJson('/api/model/local/unload', {}, true, 'POST');
                setText('ocMeta', 'Local model выгружена');
                await loadLocalLifecycleStatus(false);
            } catch (error) {
                setText('ocMeta', `Unload Local Error: ${error.message}`);
            }
        }

        async function refreshAll() {
            await updateStats();
            await loadModelCatalog(false);
            await loadOpenclawStatus(false);
        }

        document.getElementById('refreshBtn').addEventListener('click', withBtnState('refreshBtn', 'Syncing...', refreshAll));
        document.getElementById('assistantRunBtn').addEventListener('click', withBtnState('assistantRunBtn', 'Running...', assistantQuery));
        document.getElementById('assistantPlanBtn').addEventListener('click', withBtnState('assistantPlanBtn', 'Planning...', assistantPreflight));
        document.getElementById('feedbackSendBtn').addEventListener('click', withBtnState('feedbackSendBtn', 'Sending...', submitModelFeedback));
        document.getElementById('feedbackStatsBtn').addEventListener('click', withBtnState('feedbackStatsBtn', 'Loading...', loadModelFeedbackStats));
        document.getElementById('opsAckBtn').addEventListener('click', withBtnState('opsAckBtn', 'Wait...', () => opsAckAction(true)));
        document.getElementById('opsUnackBtn').addEventListener('click', withBtnState('opsUnackBtn', 'Wait...', () => opsAckAction(false)));
        document.getElementById('modelCatalogReloadBtn').addEventListener('click', withBtnState('modelCatalogReloadBtn', 'Reloading...', () => loadModelCatalog(true)));

        document.getElementById('modelApplyModeBtn').addEventListener('click', withBtnState('modelApplyModeBtn', 'Wait...', async () => {
            const mode = (document.getElementById('modelModeSelect').value || 'auto').trim();
            await applyModelAction('set_mode', { mode });
        }));
        document.getElementById('modelApplyPresetBtn').addEventListener('click', withBtnState('modelApplyPresetBtn', 'Wait...', async () => {
            const preset = (document.getElementById('modelPresetSelect').value || '').trim();
            const localModel = (document.getElementById('modelChoiceSelect').value || '').trim();
            await applyModelAction('apply_preset', { preset, local_model: localModel });
        }));
        document.getElementById('modelApplySlotBtn').addEventListener('click', withBtnState('modelApplySlotBtn', 'Wait...', async () => {
            const slot = (document.getElementById('modelSlotSelect').value || '').trim();
            const model = (document.getElementById('modelChoiceSelect').value || '').trim();
            await applyModelAction('set_slot_model', { slot, model });
        }));

        document.getElementById('modelSlotSelect').addEventListener('change', syncSlotModelSelection);
        document.getElementById('assistantAttachBtn').addEventListener('click', withBtnState('assistantAttachBtn', 'Wait...', attachSelectedFileToPrompt));
        document.getElementById('quickWebBtn').addEventListener('click', withBtnState('quickWebBtn', 'Wait...', runQuickWebSearch));
        document.getElementById('quickDeepBtn').addEventListener('click', withBtnState('quickDeepBtn', 'Wait...', runQuickDeepResearch));
        document.getElementById('quickUrlBtn').addEventListener('click', withBtnState('quickUrlBtn', 'Wait...', runQuickUrlReview));

        document.getElementById('ocRefreshBtn').addEventListener('click', withBtnState('ocRefreshBtn', 'Wait...', () => loadOpenclawStatus(true)));
        document.getElementById('ocApplyAutoswitchBtn').addEventListener('click', withBtnState('ocApplyAutoswitchBtn', 'Wait...', ocApplyAutoswitch));
        document.getElementById('ocModeLocalBtn').addEventListener('click', withBtnState('ocModeLocalBtn', 'Wait...', () => ocApplyMode('local')));
        document.getElementById('ocModeAutoBtn').addEventListener('click', withBtnState('ocModeAutoBtn', 'Wait...', () => ocApplyMode('auto')));
        document.getElementById('ocModeCloudBtn').addEventListener('click', withBtnState('ocModeCloudBtn', 'Wait...', () => ocApplyMode('cloud')));

        document.getElementById('ocLocalLoadBtn').addEventListener('click', withBtnState('ocLocalLoadBtn', 'Wait...', ocLoadLocal));
        document.getElementById('ocLocalUnloadBtn').addEventListener('click', withBtnState('ocLocalUnloadBtn', 'Wait...', ocUnloadLocal));
        document.getElementById('ocLocalRefreshBtn').addEventListener('click', withBtnState('ocLocalRefreshBtn', 'Wait...', () => loadLocalLifecycleStatus(true)));

        setInterval(updateStats, 8000);
        refreshAll();
        loadLocalLifecycleStatus(false);
    </script>
</body>

</html>
